// Code generated by sqlc-gen-ts-d1. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
//   sqlc-gen-ts-d1 v0.0.0-a@5663d287bfb2297a3d62286a1c59e21b42a39884f252829ea86d502fcebe94ef

import { D1Database, D1PreparedStatement, D1Result } from "@cloudflare/workers-types/2022-11-30"

type Query<T> = {
  then(onFulfilled?: (value: T) => void, onRejected?: (reason?: any) => void): void;
  batch(): D1PreparedStatement;
}
const getNarouNovelQuery = `-- name: GetNarouNovel :one
SELECT ncode, current_page FROM narou
WHERE ncode = ?1 LIMIT 1`;

export type GetNarouNovelParams = {
  ncode: string;
};

export type GetNarouNovelRow = {
  ncode: string;
  currentPage: number;
};

type RawGetNarouNovelRow = {
  ncode: string;
  current_page: number;
};

export function getNarouNovel(
  d1: D1Database,
  args: GetNarouNovelParams
): Query<GetNarouNovelRow | null> {
  const ps = d1
    .prepare(getNarouNovelQuery)
    .bind(args.ncode);
  return {
    then(onFulfilled?: (value: GetNarouNovelRow | null) => void, onRejected?: (reason?: any) => void) {
      ps.first<RawGetNarouNovelRow | null>()
        .then((raw: RawGetNarouNovelRow | null) => raw ? {
          ncode: raw.ncode,
          currentPage: raw.current_page,
        } : null)
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const listNarouNovelsQuery = `-- name: ListNarouNovels :many
SELECT ncode, current_page FROM narou`;

export type ListNarouNovelsRow = {
  ncode: string;
  currentPage: number;
};

type RawListNarouNovelsRow = {
  ncode: string;
  current_page: number;
};

export function listNarouNovels(
  d1: D1Database
): Query<D1Result<ListNarouNovelsRow>> {
  const ps = d1
    .prepare(listNarouNovelsQuery);
  return {
    then(onFulfilled?: (value: D1Result<ListNarouNovelsRow>) => void, onRejected?: (reason?: any) => void) {
      ps.all<RawListNarouNovelsRow>()
        .then((r: D1Result<RawListNarouNovelsRow>) => { return {
          ...r,
          results: r.results.map((raw: RawListNarouNovelsRow) => { return {
            ncode: raw.ncode,
            currentPage: raw.current_page,
          }}),
        }})
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const createNarouNovelQuery = `-- name: CreateNarouNovel :one

INSERT INTO narou (
  ncode, current_page
) VALUES (
  ?1, ?2
)
RETURNING ncode, current_page`;

export type CreateNarouNovelParams = {
  ncode: string;
  currentPage: number;
};

export type CreateNarouNovelRow = {
  ncode: string;
  currentPage: number;
};

type RawCreateNarouNovelRow = {
  ncode: string;
  current_page: number;
};

export function createNarouNovel(
  d1: D1Database,
  args: CreateNarouNovelParams
): Query<CreateNarouNovelRow | null> {
  const ps = d1
    .prepare(createNarouNovelQuery)
    .bind(args.ncode, args.currentPage);
  return {
    then(onFulfilled?: (value: CreateNarouNovelRow | null) => void, onRejected?: (reason?: any) => void) {
      ps.first<RawCreateNarouNovelRow | null>()
        .then((raw: RawCreateNarouNovelRow | null) => raw ? {
          ncode: raw.ncode,
          currentPage: raw.current_page,
        } : null)
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const updateNarouNovelQuery = `-- name: UpdateNarouNovel :exec
UPDATE narou
set current_page = ?1
WHERE ncode = ?2`;

export type UpdateNarouNovelParams = {
  currentPage: number;
  ncode: string;
};

export function updateNarouNovel(
  d1: D1Database,
  args: UpdateNarouNovelParams
): Query<D1Result> {
  const ps = d1
    .prepare(updateNarouNovelQuery)
    .bind(args.currentPage, args.ncode);
  return {
    then(onFulfilled?: (value: D1Result) => void, onRejected?: (reason?: any) => void) {
      ps.run()
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const deleteNarouNovelQuery = `-- name: DeleteNarouNovel :exec
DELETE FROM narou
WHERE ncode = ?1`;

export type DeleteNarouNovelParams = {
  ncode: string;
};

export function deleteNarouNovel(
  d1: D1Database,
  args: DeleteNarouNovelParams
): Query<D1Result> {
  const ps = d1
    .prepare(deleteNarouNovelQuery)
    .bind(args.ncode);
  return {
    then(onFulfilled?: (value: D1Result) => void, onRejected?: (reason?: any) => void) {
      ps.run()
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

